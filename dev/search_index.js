var documenterSearchIndex = {"docs":
[{"location":"benchmarking/#Benchmarking","page":"Benchmarking","title":"Benchmarking","text":"This section shows various benchmarks.","category":"section"},{"location":"benchmarking/#Runs-of-different-durations","page":"Benchmarking","title":"Runs of different durations","text":"# benchmark for a typical daedalus run of 600 days\nusing Daedalus\nusing BenchmarkTools\n\n@benchmark daedalus(time_end=600.0)\n\n# benchmark for an RTM-exercise run of 100 days\nusing Daedalus\nusing BenchmarkTools\n\n@benchmark daedalus(time_end=100.0)","category":"section"},{"location":"benchmarking/#Effect-of-logging-R_t","page":"Benchmarking","title":"Effect of logging R_t","text":"Logging R_t in each timestep slows the simulation down by a lot.\n\nusing Daedalus\nusing BenchmarkTools\n\n# turn off Rt logging and compare with benchmark above\n@benchmark daedalus(log_rt=false, time_end=600.0)","category":"section"},{"location":"benchmarking/#Reactive-events","page":"Benchmarking","title":"Reactive events","text":"Reactive events currently require logging R_t so are not benchmarked with logging turned off.\n\n# benchmark for an RTM-exercise run of 100 days\nusing Daedalus\nusing BenchmarkTools\n\nnpi = Daedalus.DaedalusStructs.Npi(20000.0, (coef=0.7,));\n\n@benchmark daedalus(r0=5.0, npi=npi, time_end=600.0)\n\n# shorter duration\n@benchmark daedalus(r0=5.0, npi=npi, time_end=100.0)","category":"section"},{"location":"benchmarking/#Timed-events","page":"Benchmarking","title":"Timed events","text":"# benchmark for a full run of 600 days\nusing Daedalus\nusing BenchmarkTools\n\ntimed_npi = Daedalus.DaedalusStructs.TimedNpi(\n    [60.0, 180.0, 300.0],\n    [120.0, 200.0, 365.0],\n    [0.3, 0.7, 0.5],\n    \"three_phase_lockdown\"\n)\n\n@benchmark daedalus(r0=3.0, npi=timed_npi, time_end=600.0)\n\nTimed events do not need R_t logging and can be benchmarked without it.\n\n@benchmark daedalus(r0=3.0, npi=timed_npi, time_end=600.0, log_rt=false)","category":"section"},{"location":"pkg_index/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"musings/","page":"Implementing reactive events","title":"Implementing reactive events","text":"This page for recording why reactive events are implemented in the way they are, and the way forward for both reactive state-dependent, timed, and mixed event types in Daedalus.jl and ODE models.","category":"section"},{"location":"npis/","page":"Reactive NPIs","title":"Reactive NPIs","text":"This module show how to use the Npi type to specify reactive events.","category":"section"},{"location":"npis/#Reactive-NPIs","page":"Reactive NPIs","title":"Reactive NPIs","text":"Updated to use the general Npi class rather than specialised TimedNpi and ReactiveNpi classes.\n\nusing Daedalus\nusing Plots\n\n# create an Npi with the easy to use constructor\nhosp_threshold=20000.0\na = Daedalus.DaedalusStructs.Npi(hosp_threshold, (coef=0.7,));\n\ndata = daedalus(r0=3.0, npi=a, time_end=600.0);\ndata_default = daedalus(r0=3.0, time_end=600.0);\n\n# plot new hosp over time\niHosp = Daedalus.Constants.get_indices(\"H\")\nhosp = [sum(x[iHosp]) for x in data.sol(0:600)]\nhosp_default = [sum(x[iHosp]) for x in data_default.sol(0:600)]\n\niRt = Daedalus.Constants.get_indices(\"Rt\")\nrt = [x[iRt] for x in data.sol(0:600)]\nrt_default = [x[iRt] for x in data_default.sol(0:600)]\ntimes = unique(data.sol.t)\n\nplot(times, hosp, label=\"Hosp w/ NPI\")\nplot!(times, hosp_default, label=\"Hosp w/o NPI\")\nxlabel!(\"Time (days)\")\nylabel!(\"Hosp occupancy\")\n\nPlot R_t to see more differences.\n\nplot(times, rt, label=\"Rt w/ NPI\")\nplot!(times, rt_default, label=\"Rt w/o NPI\")\nxlabel!(\"Time (days)\")\nylabel!(\"Rt\")","category":"section"},{"location":"npis/#Timed-NPIs","page":"Reactive NPIs","title":"Timed NPIs","text":"Timed NPIs are responsive only to time and not state. These were translated from the implementation in the R package daedalus using Claude Sonnet 4.5 as a way of trying out Claude.\n\nusing Daedalus\nusing Plots\n\n# define a timed npi giving the start times, end times, and beta scaling\ntimed_npi = Daedalus.DaedalusStructs.TimedNpi(\n    [60.0, 180.0, 300.0],\n    [120.0, 200.0, 365.0],\n    [0.3, 0.7, 0.5],\n    \"three_phase_lockdown\"\n)\n\ndata = daedalus(r0=3.0, npi=timed_npi, time_end=600.0);\n\n# get exposed\niExpo = Daedalus.Constants.get_indices(\"E\")\nexposed = [sum(x[iExpo]) for x in data.sol(0:600)]\ntimes = unique(data.sol.t)\n\nplot(times, exposed, label=\"Incidence w/ NPI\")\nxlabel!(\"Time (days)\")\nylabel!(\"Incidence\")","category":"section"},{"location":"reference/#Function-reference","page":"Function Reference","title":"Function reference","text":"","category":"section"},{"location":"reference/#Daedalus.daedalus-Tuple{}","page":"Function Reference","title":"Daedalus.daedalus","text":"daedalus()\n\nModel the progression of a daedalus epidemic with multiple optional vaccination strata.\n\nArguments\n\nnpi: Non-pharmaceutical intervention. Can be:\nNpi: Reactive NPI that responds to epidemic state (hospitalizations, Rt)\nTimedNpi: Time-limited NPI with predefined start/end times\nnothing: No intervention (default)\n\nExamples\n\nNo intervention\n\nresult = daedalus(r0=2.5, time_end=200.0)\n\nSingle-phase time-limited intervention\n\n# 30% transmission reduction from day 15 to day 45\nnpi = TimedNpi(15.0, 45.0, 0.7, \"moderate_lockdown\")\nresult = daedalus(r0=2.5, time_end=200.0, npi=npi)\n\nMulti-phase time-limited intervention\n\n# Three phases: moderate → strict → relaxed\nnpi = TimedNpi(\n    [10.0, 30.0, 60.0],  # start times\n    [25.0, 55.0, 90.0],  # end times\n    [0.7, 0.3, 0.5],     # coefficients\n    \"three_phase_strategy\"\n)\nresult = daedalus(r0=2.5, time_end=200.0, npi=npi)\n\nReactive (state-dependent) intervention\n\n# Triggers when hospitalizations reach threshold, deactivates when Rt < 1\nnpi = Npi(5000.0, (coef=0.4,))\nresult = daedalus(r0=2.5, time_end=200.0, npi=npi)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Daedalus.Data.aus_workers-Tuple{}","page":"Function Reference","title":"Daedalus.Data.aus_workers","text":"aus_workers()\n\nGet number of workers in DAEDALUS economic sectors.\n\nAll sectors have one additional worker to avoid zero division.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Daedalus.Data.australia_contacts-Tuple{}","page":"Function Reference","title":"Daedalus.Data.australia_contacts","text":"australia_contacts()\n\nGet contacts between DAEDALUS demography groups as a matrix.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Daedalus.Data.australia_demography-Tuple{}","page":"Function Reference","title":"Daedalus.Data.australia_demography","text":"australia_demography()\n\nGet number of individuals in each DAEDALUS demography group.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Daedalus.Data.australia_initial_state","page":"Function Reference","title":"Daedalus.Data.australia_initial_state","text":"australia_initial_state()\n\nInitial state with seven compartments: S, E, Is, Ia, R, D, and H, and four age groups and 49 economic sectors (comprised of working age individuals), and two vaccination strata for unvaccinated and vaccinated individuals.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Daedalus.Data.worker_contacts","page":"Function Reference","title":"Daedalus.Data.worker_contacts","text":"worker_contacts()\n\nGet a dummy value of worker contacts within economic sectors.\n\nThis data is synthetic and not generated from the R package {daedalus}.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Daedalus.Ode.daedalus_ode!-Tuple{Array, Array, Daedalus.DaedalusStructs.Params, Number}","page":"Function Reference","title":"Daedalus.Ode.daedalus_ode!","text":"daedalus_ode!(du, u, p, t)\n\nThe ODE system for the DAEDALUS model. This function is intended to be called     internally from daedalus.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Daedalus.DaedalusStructs.Npi","page":"Function Reference","title":"Daedalus.DaedalusStructs.Npi","text":"Npi\n\nA struct to specify an NPI. The idea here is for the NPI to be reactive to     compartmental values which are logged at discrete time points.     The struct is mutable so that saved_values can be updated.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Daedalus.DaedalusStructs.NpiData","page":"Function Reference","title":"Daedalus.DaedalusStructs.NpiData","text":"NpiData\n\nA struct to hold common reactive response parameters.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Daedalus.DaedalusStructs.Params","page":"Function Reference","title":"Daedalus.DaedalusStructs.Params","text":"Params\n\nA mutable struct that holds the parameters for the DAEDALUS model.     It contains the contact matrices, contact weights, and various     epidemiological parameters.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Daedalus.DaedalusStructs.TimedNpi","page":"Function Reference","title":"Daedalus.DaedalusStructs.TimedNpi","text":"TimedNpi\n\nA struct to specify time-limited non-pharmaceutical interventions (NPIs). Unlike Npi, these interventions are purely time-based and do not respond to epidemic state. Supports multiple intervention phases with different intensity levels.\n\nFields\n\nstart_times::Vector{Float64}: Start times for each intervention phase (days)\nend_times::Vector{Float64}: End times for each intervention phase (days)\ncoefs::Vector{Float64}: Transmission reduction coefficient for each phase. Values should be in [0, 1] where 1 = no intervention, 0 = complete transmission block.\nidentifier::String: Name or description of the intervention strategy\n\nConstraints\n\nAll vectors must have the same length\nend_times[i] >= start_times[i] for all i\nTime intervals must be non-overlapping\nTimes must be sorted in ascending order\nCoefficients must be in [0, 1]\n\nExample\n\n# Three-phase intervention: moderate → strict → relaxed\ntimed_npi = TimedNpi(\n    [10.0, 30.0, 60.0],  # start times\n    [25.0, 55.0, 90.0],  # end times\n    [0.7, 0.3, 0.5],     # coefs (0.7 = 30% reduction, 0.3 = 70% reduction)\n    \"three_phase_lockdown\"\n)\n\n\n\n\n\n","category":"type"},{"location":"reference/#Daedalus.DaedalusStructs.n_phases-Tuple{Daedalus.DaedalusStructs.TimedNpi}","page":"Function Reference","title":"Daedalus.DaedalusStructs.n_phases","text":"n_phases(npi::TimedNpi)\n\nReturn the number of intervention phases in a TimedNpi.\n\nExample\n\nnpi = TimedNpi([10.0, 30.0], [20.0, 40.0], [0.7, 0.5])\nn_phases(npi)  # Returns: 2\n\n\n\n\n\n","category":"method"},{"location":"reference/#Daedalus.DaedalusStructs.total_duration-Tuple{Daedalus.DaedalusStructs.TimedNpi}","page":"Function Reference","title":"Daedalus.DaedalusStructs.total_duration","text":"total_duration(npi::TimedNpi)\n\nCalculate the total duration of all intervention phases combined (not including gaps between phases).\n\nReturns\n\nTotal days of active intervention\n\nExample\n\nnpi = TimedNpi([10.0, 30.0], [20.0, 40.0], [0.7, 0.5])\n# Phase 1: 10 days (10-20), Phase 2: 10 days (30-40)\ntotal_duration(npi)  # Returns: 20.0\n\n\n\n\n\n","category":"method"},{"location":"reference/#Daedalus.Events.make_events-Tuple{Daedalus.DaedalusStructs.Npi, Function, Function, Any}","page":"Function Reference","title":"Daedalus.Events.make_events","text":"make_events(x::Npi)\n\nMake a CallbackSet from a Npi struct.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Daedalus.Events.make_param_changer-Tuple{Any, Any, Any}","page":"Function Reference","title":"Daedalus.Events.make_param_changer","text":"make_param_changer(param_name, func, coef)\n\nA function factory to generate effect functions.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Daedalus.Events.make_rt_logger-Tuple{Any}","page":"Function Reference","title":"Daedalus.Events.make_rt_logger","text":"make_rt_logger(savepoints)\n\nMake a PresetTimeCallback to update Rt.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Daedalus.Events.make_save_events-Tuple{Daedalus.DaedalusStructs.Npi, Any}","page":"Function Reference","title":"Daedalus.Events.make_save_events","text":"make_save_events(x::Npi, savepoints)\n\nMake a CallbackSet of SavingCallbacks from an Npi struct. savepoints is     expected to be a float range.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Daedalus.Events.make_state_condition-Tuple{Any, Any, Function}","page":"Function Reference","title":"Daedalus.Events.make_state_condition","text":"make_cond(threshold)::Function\n\nFactory function for conditions. Makes a function that checks whether a root is     found at the sum of a state index. Passing crossing = \"up\" checks for an     increasing root (-1 to +1), while crossing = \"down\" checks for a     decreasing root (+1 to -1).\n\n\n\n\n\n","category":"method"},{"location":"reference/#Daedalus.Events.make_timed_npi_callbacks-Tuple{Daedalus.DaedalusStructs.TimedNpi}","page":"Function Reference","title":"Daedalus.Events.make_timed_npi_callbacks","text":"make_timed_npi_callbacks(npi::TimedNpi)\n\nCreate a set of callbacks for time-limited NPIs that activate and deactivate at specified times. Each intervention phase applies a transmission reduction coefficient to the beta parameter.\n\nArguments\n\nnpi::TimedNpi: A TimedNpi struct containing intervention timing and coefficients\n\nReturns\n\nCallbackSet: A set of PresetTimeCallback objects that modify beta at the specified intervention times\n\nDetails\n\nThe function creates paired callbacks for each intervention phase:\n\nAt start_times[i], beta is multiplied by coefs[i]\nAt end_times[i], beta is reset to its original value\n\nBetween phases, the original beta value is restored. Multiple phases can be specified to create complex intervention scenarios.\n\nExample\n\ntimed_npi = TimedNpi([10.0, 30.0], [20.0, 40.0], [0.5, 0.3], \"two_phase\")\ncallbacks = make_timed_npi_callbacks(timed_npi)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Daedalus.Helpers.dominant_eigenvalue-Tuple{AbstractMatrix}","page":"Function Reference","title":"Daedalus.Helpers.dominant_eigenvalue","text":"dominant_eigenvalue(A; v_init=nothing, max_iter=100, tol=1e-6)\n\nCompute the dominant (largest magnitude) eigenvalue using power iteration. This is significantly faster than computing all eigenvalues when only the largest eigenvalue is needed.\n\nArguments\n\nA::AbstractMatrix: The matrix whose dominant eigenvalue is to be computed\nv_init::Union{Nothing,AbstractVector}: Optional initial vector for iteration. If not provided, a random vector is used.\nmax_iter::Int: Maximum number of iterations (default: 100)\ntol::Float64: Convergence tolerance (default: 1e-6)\n\nReturns\n\nThe dominant eigenvalue (largest in magnitude)\n\nAlgorithm\n\nUses the power iteration method: repeatedly multiplies a vector by the matrix and normalizes. The Rayleigh quotient converges to the dominant eigenvalue.\n\nPerformance\n\nFor n×n matrices, this method is O(kn²) where k is the number of iterations (typically k << n), compared to O(n³) for full eigendecomposition.\n\nExample\n\nA = rand(49, 49)\nλ_dom = dominant_eigenvalue(A)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Daedalus.Helpers.get_beta-NTuple{7, Any}","page":"Function Reference","title":"Daedalus.Helpers.get_beta","text":"get_beta(\n    cm, r0, sigma, p_sigma, epsilon, gamma_Ia, gamma_Is\n)\n\nCalculate the transmission rate beta given the contact matrix and other parameters.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Daedalus.Helpers.get_ngm-NTuple{7, Any}","page":"Function Reference","title":"Daedalus.Helpers.get_ngm","text":"get_ngm(\n    cm, r0, sigma, p_sigma, epsilon, gamma_Ia, gamma_Is\n)\n\nCalculate the next-generation matrix (NGM) given the contact matrix and other parameters.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Daedalus.Helpers.sum_by_age-Tuple{Any, Any}","page":"Function Reference","title":"Daedalus.Helpers.sum_by_age","text":"sum_by_age(state, index)\n\nSum the state array over economic groups into age groups for a given compartment index.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Daedalus.Constants.get_indices-Tuple{String}","page":"Function Reference","title":"Daedalus.Constants.get_indices","text":"get_indices(compartment::String)\n\nGet compartment indices for state tests.\n\n\n\n\n\n","category":"method"},{"location":"#Daedalus.jl","page":"Home","title":"Daedalus.jl","text":"This is some minimal documentation for Daedalus.jl.\n\nNote that this is a personal project, and comes with no current or future support. This documentation section is intended as a learning experience (for me) in writing Julia package documentation.\n\n(Image: License:MIT) (Image: Project Status: Concept – Minimal or no implementation has been done yet, or the repository is only intended to be a limited example, demo, or proof-of-concept.) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: SciML Code Style)\n\nDaedalus.jl is a Julia package that aims to mirror the R package {daedalus}.\n\nThis section shows how to run the Daedalus Julia model. Functionality compared to the R package is limited.\n\nusing Daedalus\nusing Plots\n\n# pump up r0 to get peak within 50 days\ndata = daedalus(r0=5.0, time_end=600.0);\n\n# plot exposed group\niExposed = Daedalus.Constants.get_indices(\"E\")\niHosp = Daedalus.Constants.get_indices(\"H\")\nexposed = [sum(x[iExposed]) for x in data.sol.u]\nhosp = [sum(x[iHosp]) for x in data.sol.u]\n\n# plot the output to see lag in hospitalisations\nplot(data.sol.t, exposed, label=\"exposed\")\nplot!(data.sol.t, hosp, label=\"hosp\")\nxlabel!(\"Time (days)\")\nylabel!(\"# individuals\")\n\n# plot recorded Rt\niRt = Daedalus.Constants.get_indices(\"Rt\")\nplot(data.sol.t, [x[iRt] for x in data.sol.u], label=\"Rt\")\nxlabel!(\"Time (days)\")\nylabel!(\"Rt\")","category":"section"}]
}
